#ifndef __CL_RANDOM_H__
#define __CL_RANDOM_H__

static uint xor_shift_rng(uint *state)
{
  *state ^= (*state << 13);
  *state ^= (*state >> 17);
  *state ^= (*state << 5);
  return *state;
}

static float sample_unit_1D (uint *state)
{
	return (
    (float)(xor_shift_rng(state)) / (float)(UINT_MAX)
  );
}

static float2 sample_unit_2D (uint *state)
{
	return ((float2)(
    (float)(xor_shift_rng(state)) / (float)(UINT_MAX),
    (float)(xor_shift_rng(state)) / (float)(UINT_MAX)
  ));
}

static float3 sample_unit_3D (uint *state)
{
	return ((float3)(
    (float)(xor_shift_rng(state)) / (float)(UINT_MAX),
    (float)(xor_shift_rng(state)) / (float)(UINT_MAX),
    (float)(xor_shift_rng(state)) / (float)(UINT_MAX)
  ));
}

static int rot(int x, int b) {
  return (x << b) ^ (x >> (32-b));
}

static uint hash2(int i, int j) {
	int a = i;
	int b = j;
	for (int r = 0; r < 3; r++) {
		a = rot ((int) ((a^0xcafebabe) + (b^0xfaceb00c)), 23);
		b = rot ((int) ((a^0xdeadbeef) + (b^0x8badf00d)), 5);
	}
	return (uint)(a^b);
}

static uint hash(int i) {
	int a = i;
	int b = 0;
	for (int r = 0; r < 3; r++) {
		a = rot ((int) ((a^0xcafebabe) + (b^0xfaceb00c)), 23);
		b = rot ((int) ((a^0xdeadbeef) + (b^0x8badf00d)), 5);
	}
	return (uint)(a^b);
}


/*
 * Sample unit sphere by sampling unit cube and reject
 * rng_state: current state used by xor random generator
 * normal: align sampled direction along this vector
 * a normalized random vector in unit sphere
 */
static float3 sample_unit_sphere_rejection(uint* rng_state, float3 normal)
{
    float3 p;
    do {
        p = 2.0f * sample_unit_3D(rng_state) - (float3)(1,1,1);
    } while (dot(p,p) >= 1.0f);

    return normalize(normal + p);
}

#endif //__CL_RANDOM_H__
